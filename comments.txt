A program written and designed by Karl Flores & Kristian Bjarnason
for the University of Melbourne subject COMP30024, Artificial Intelligence.

***Calculating number of moves***
Time Complexity:


Space Complexity:


***Calculating sequence of moves***
How we modelled the problem as a search problem:
We create new board representations depending on possible moves and place
these in a tree structure, where the nth layer is n moves away. We then search
this tree to find a board representation that matches the desired outcome
(no black pieces remain).

Search algorithm used:
Iterative Deepening Depth First Search.

Branching factor of our search tree (if applicable):
For each node, the branching factor is the number of available moves. Theoretically
this means it could be as low as 0 or as high as 96, or any value in between. If we
were to take the middle case this would mean there would be a branching factor of 48.


Algorithm optimality:
Yes algorithm explores level by level (which represent number of moves),
meaning it will return the optimal/shortest set of moves to make.
